<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>空間設計器 - 圓形家具與完美置中版</title>
    <style>
        :root { --primary: #4A90E2; --bg: #1a1a1a; --accent: #8e44ad; }
        body { font-family: "Microsoft JhengHei", sans-serif; display: flex; flex-direction: row; margin: 0; background-color: var(--bg); height: 100dvh; overflow: hidden; }

        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { width: 100% !important; height: 42dvh; order: 2; border-top: 1px solid #444; }
            #canvas-container { height: 58dvh; order: 1; }
        }

        #sidebar { width: 320px; padding: 15px; background: white; box-shadow: 2px 0 5px rgba(0,0,0,0.1); overflow-y: auto; z-index: 10; position: relative; }
        
        #canvas-container { 
            flex-grow: 1; 
            background: #333; 
            overflow: hidden; 
            position: relative; 
            touch-action: none;
        }

        canvas { 
            background-color: white; 
            display: block; 
            position: absolute; /* 強制絕對定位以精確控制置中 */
            top: 10px;
            left: 50%;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            transform-origin: center center;
        }

        .accordion-header { display: flex; justify-content: space-between; align-items: center; background: #f1f3f5; padding: 10px; border-radius: 5px; cursor: pointer; border: 1px solid #ddd; margin-top: 8px; font-weight: bold; font-size: 14px; }
        .accordion-content { display: none; padding: 10px; border: 1px solid #ddd; border-top: none; background: #fff; }
        .accordion-content.active { display: block; }
        
        .shape-selector { display: flex; gap: 5px; margin-bottom: 8px; }
        .shape-btn { flex: 1; padding: 8px; border: 1px solid #ccc; background: #eee; cursor: pointer; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .shape-btn.active { background: var(--primary); color: white; border-color: var(--primary); }

        input { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; margin-bottom: 5px; }
        .color-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
        .color-dot { width: 100%; aspect-ratio: 1; border-radius: 3px; cursor: pointer; border: 1px solid rgba(0,0,0,0.1); }
        button { width: 100%; padding: 12px; cursor: pointer; background: var(--primary); color: white; border: none; border-radius: 5px; font-weight: bold; margin-bottom: 5px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h3 style="margin:0 0 10px 0;">空間設計 (950x740)</h3>
    <button onclick="addFurniture()">＋ 新增家具</button>
    <button style="background:var(--accent)" onclick="addZone()">＋ 新增區域底色</button>

    <div class="accordion-header active" onclick="toggleAccordion('listContent')">
        <span>家具清單 <small id="furnitureCount">(0)</small></span>
        <span>▼</span>
    </div>
    <div id="listContent" class="accordion-content active">
        <div id="furnitureListContainer"></div>
    </div>

    <div id="editPanel" style="display:none;">
        <div class="accordion-header active" onclick="toggleAccordion('furnitureContent')">
            <span>編輯家具</span>
            <span>▼</span>
        </div>
        <div id="furnitureContent" class="accordion-content active">
            <label style="font-size:12px; color:#666;">家具形狀：</label>
            <div class="shape-selector">
                <button id="shapeRect" class="shape-btn" onclick="setShape('rect')">方形</button>
                <button id="shapeCircle" class="shape-btn" onclick="setShape('circle')">圓形</button>
            </div>
            
            <input type="text" id="editName" oninput="updateSelected()" placeholder="名稱">
            <div style="display: flex; gap: 5px;">
                <input type="number" id="editW" oninput="updateSelected()" placeholder="寬/直徑">
                <input type="number" id="editH" oninput="updateSelected()" placeholder="高">
            </div>
            <div class="color-grid" id="colorGrid"></div>
            <div style="display: flex; gap: 5px; margin-top: 5px;">
                <button style="background:#607d8b; flex:1;" onclick="rotateStep(-30)">↺ -30°</button>
                <button style="background:#607d8b; flex:1;" onclick="rotateStep(30)">+30° ↻</button>
            </div>
            <button style="background:#e74c3c" onclick="deleteSelected()">刪除家具</button>
        </div>
    </div>

    <div class="accordion-header" onclick="toggleAccordion('zoneContent')">
        <span>區域管理</span>
        <span>▼</span>
    </div>
    <div id="zoneContent" class="accordion-content">
        <div id="zoneList"></div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="roomCanvas" width="950" height="740"></canvas>
</div>

<script>
    const canvas = document.getElementById('roomCanvas');
    const container = document.getElementById('canvas-container');
    const ctx = canvas.getContext('2d');
    const CW = 950, CH = 740;
    const PRESET_COLORS = ["#ffb347", "#222222", "#aec6cf", "#77dd77", "#fdfd96", "#cfcfc4", "#ff6961", "#836953", "#c23b22", "#03c03c", "#5d8aa8", "#ffffff"];

    let view = { x: 0, y: 0, scale: 1 }; 
    let furnitures = [], zones = [], selectedIndex = -1;
    let isDragging = false, isPanning = false, lastTouch = { x: 0, y: 0 };
    let initialPinchDist = 0, initialScale = 1;

    initColorGrid();
    zones.push({ name: "走道", x: 0, y: 0, w: 150, h: 740, color: "#ffb347" });
    zones.push({ name: "柱子1", x: 430, y: 700, w: 40, h: 40, color: "#222222" });
    zones.push({ name: "柱子2", x: 430, y: 0, w: 40, h: 40, color: "#222222" });
    renderZoneList();

    function autoFit() {
        const padding = 40; // 增加邊距緩衝
        const availableW = container.clientWidth - padding;
        const availableH = container.clientHeight - padding;
        view.scale = Math.min(availableW / CW, availableH / CH);
        // 重置為絕對居中位移
        view.x = 0; view.y = 0;
        applyTransform();
    }

    window.onload = autoFit;
    window.onresize = autoFit;

    function applyTransform() {
        // 使用 translateX(-50%) 來配合 left: 50% 達成完美水平居中
        canvas.style.transform = `translate3d(calc(-50% + ${view.x}px), ${view.y}px, 0) scale(${view.scale})`;
    }

    function toggleAccordion(id) { document.getElementById(id).classList.toggle('active'); }

    function initColorGrid() {
        const grid = document.getElementById('colorGrid');
        PRESET_COLORS.forEach(color => {
            const dot = document.createElement('div');
            dot.className = 'color-dot';
            dot.style.backgroundColor = color;
            dot.onclick = () => { if (selectedIndex !== -1) furnitures[selectedIndex].color = color; };
            grid.appendChild(dot);
        });
    }

    function addFurniture() {
        furnitures.push({ x: 400, y: 300, w: 100, h: 100, rotation: 0, name: "新家具", color: "#aec6cf", shape: "rect" });
        selectedIndex = furnitures.length - 1;
        updateUI();
    }

    function setShape(shape) {
        if (selectedIndex !== -1) {
            furnitures[selectedIndex].shape = shape;
            updateUI();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CW, CH);
        zones.forEach(z => {
            ctx.fillStyle = z.color;
            ctx.fillRect(z.x, CH - (z.y + z.h), z.w, z.h);
        });
        
        // 網格
        for (let i = 0; i <= CW; i += 50) {
            ctx.beginPath(); ctx.strokeStyle = (i % 100 === 0) ? '#666' : '#999';
            ctx.lineWidth = (i % 100 === 0) ? 1.5 : 0.8;
            ctx.moveTo(i, 0); ctx.lineTo(i, CH); ctx.stroke();
            if (i % 100 === 0) { ctx.fillStyle = '#444'; ctx.font = 'bold 12px Arial'; ctx.fillText(i, i + 2, CH - 5); }
        }
        for (let j = 0; j <= CH; j += 50) {
            ctx.beginPath(); ctx.strokeStyle = (j % 100 === 0) ? '#666' : '#999';
            ctx.lineWidth = (j % 100 === 0) ? 1.5 : 0.8;
            ctx.moveTo(0, CH - j); ctx.lineTo(CW, CH - j); ctx.stroke();
            if (j % 100 === 0 && j !== 0) { ctx.fillStyle = '#444'; ctx.font = 'bold 12px Arial'; ctx.fillText(j, 5, CH - j - 2); }
        }

        // 家具繪製
        furnitures.forEach((f, idx) => {
            ctx.save();
            ctx.translate(f.x + f.w/2, CH - (f.y + f.h/2));
            ctx.rotate(-f.rotation * Math.PI / 180);
            ctx.fillStyle = f.color;
            ctx.strokeStyle = (idx === selectedIndex) ? '#4A90E2' : '#333';
            ctx.lineWidth = (idx === selectedIndex) ? 4 : 2;

            if (f.shape === "circle") {
                ctx.beginPath();
                ctx.arc(0, 0, f.w / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.fillRect(-f.w/2, -f.h/2, f.w, f.h);
                ctx.strokeRect(-f.w/2, -f.h/2, f.w, f.h);
            }

            ctx.fillStyle = (f.color === "#222222") ? "white" : "#333";
            ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(f.name, 0, 0);
            ctx.restore();
        });
        requestAnimationFrame(draw);
    }

    function screenToCanvas(sx, sy) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (sx - rect.left) / (rect.width / CW),
            y: CH - ((sy - rect.top) / (rect.height / CH))
        };
    }

    container.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            const c = screenToCanvas(touch.clientX, touch.clientY);
            let found = false;
            for (let i = furnitures.length - 1; i >= 0; i--) {
                const f = furnitures[i];
                if (c.x >= f.x && c.x <= f.x + f.w && c.y >= f.y && c.y <= f.y + f.h) {
                    selectedIndex = i; isDragging = true;
                    lastTouch = { x: c.x - f.x, y: c.y - f.y };
                    found = true; break;
                }
            }
            if (!found) { 
                selectedIndex = -1; isPanning = true; 
                lastTouch = { x: touch.clientX, y: touch.clientY };
            }
        } else if (e.touches.length === 2) {
            isDragging = false; isPanning = false;
            initialPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            initialScale = view.scale;
        }
        updateUI();
    }, { passive: false });

    container.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (isDragging && selectedIndex !== -1) {
                const c = screenToCanvas(touch.clientX, touch.clientY);
                furnitures[selectedIndex].x = c.x - lastTouch.x;
                furnitures[selectedIndex].y = c.y - lastTouch.y;
            } else if (isPanning) {
                view.x += (touch.clientX - lastTouch.x);
                view.y += (touch.clientY - lastTouch.y);
                lastTouch = { x: touch.clientX, y: touch.clientY };
                applyTransform();
            }
        } else if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            view.scale = initialScale * (dist / initialPinchDist);
            applyTransform();
        }
    }, { passive: false });

    function updateUI() {
        const panel = document.getElementById('editPanel');
        if (selectedIndex !== -1) {
            panel.style.display = 'block';
            const f = furnitures[selectedIndex];
            document.getElementById('editName').value = f.name;
            document.getElementById('editW').value = f.w;
            document.getElementById('editH').value = f.h;
            // 更新按鈕狀態
            document.getElementById('shapeRect').className = `shape-btn ${f.shape === 'rect' ? 'active' : ''}`;
            document.getElementById('shapeCircle').className = `shape-btn ${f.shape === 'circle' ? 'active' : ''}`;
            // 隱藏/顯示高度輸入框 (圓形只需要寬度/直徑)
            document.getElementById('editH').style.display = f.shape === 'circle' ? 'none' : 'block';
        } else { panel.style.display = 'none'; }
        updateList();
    }

    function updateList() {
        const list = document.getElementById('furnitureListContainer');
        document.getElementById('furnitureCount').innerText = `(${furnitures.length})`;
        list.innerHTML = '';
        furnitures.forEach((f, idx) => {
            const li = document.createElement('div');
            li.className = `item-list-li ${idx === selectedIndex ? 'selected' : ''}`;
            const sizeText = f.shape === 'circle' ? `直徑 ${f.w}` : `${f.w}x${f.h}`;
            li.innerHTML = `<span>${f.name} (${f.shape==='rect'?'方':'圓'})</span><small>${sizeText} cm</small>`;
            li.onclick = () => { selectedIndex = idx; updateUI(); };
            list.appendChild(li);
        });
    }

    function renderZoneList() {
        const container = document.getElementById('zoneList');
        container.innerHTML = '';
        zones.forEach((z, idx) => {
            const div = document.createElement('div');
            div.style.borderBottom = '1px solid #eee'; div.style.padding = '8px 0';
            div.innerHTML = `
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <input type="text" value="${z.name}" oninput="zones[${idx}].name=this.value" style="flex:1; font-size:12px; margin:0">
                    <button onclick="zones.splice(${idx},1);renderZoneList()" style="width:30px; background:#e74c3c; border:none; color:white;">✕</button>
                </div>
                <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:2px;">
                    <input type="number" value="${z.x}" oninput="zones[${idx}].x=parseFloat(this.value)||0">
                    <input type="number" value="${z.y}" oninput="zones[${idx}].y=parseFloat(this.value)||0">
                    <input type="number" value="${z.w}" oninput="zones[${idx}].w=parseFloat(this.value)||0">
                    <input type="number" value="${z.h}" oninput="zones[${idx}].h=parseFloat(this.value)||0">
                </div>
                <div class="color-grid" style="grid-template-columns: repeat(12, 1fr); margin-top:5px;">
                    ${PRESET_COLORS.map(c => `<div style="background:${c}; height:10px; cursor:pointer;" onclick="zones[${idx}].color='${c}'"></div>`).join('')}
                </div>`;
            container.appendChild(div);
        });
    }

    function updateSelected() {
        if (selectedIndex !== -1) {
            const f = furnitures[selectedIndex];
            f.name = document.getElementById('editName').value;
            f.w = parseFloat(document.getElementById('editW').value) || 1;
            f.h = parseFloat(document.getElementById('editH').value) || 1;
        }
    }
    function rotateStep(deg) { if (selectedIndex !== -1) furnitures[selectedIndex].rotation += deg; }
    function deleteSelected() { if (selectedIndex !== -1) { furnitures.splice(selectedIndex, 1); selectedIndex = -1; updateUI(); } }
    function addZone() { zones.push({ name: "新區域", x: 200, y: 200, w: 100, h: 100, color: "#eeeeee" }); renderZoneList(); }

    draw();
</script>
</body>
</html>
